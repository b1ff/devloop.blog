---
slug: "/blog/tests-is-speed"
date: "2021-08-13"
author: "Евгений"
---
# Тесты нужны для скорости

<!-- cut -->
Я постоянно слышу о том что, что бы писать тесты нужно увеличить оценку по времени задачи в 1.2, 1.5, 2, 3 раза.
Обычно я не спорю с этим, так как команде виднее, но внутри меня частенько бурлит, или как минимум подбурливает.
Хотел бы объяснить свой взгляд на автоматические тесты, и почему считаю что такое увеличение не совсем корректное.
<!-- cut -->

## Как мы обычно разрабатываем

В данном разделе я имею в виду сценарии, при которых нам хотя бы немного важно качество.
И так, у нас есть какой-то проект, предположим это API. Предположим нам надо расширить тот самый API.
Так или иначе нам нужно проверить результат, что API отрабатывает как надо.
Для этого мы после каждого изменения стартуем процесс с API. Заходим в какой-то swagger или postman, делаем запрос с нужными данными и смотрим результат.

_Таааак... тут у нас упало... Ага понял где упало, правим. Завелось. Делаем дальнейшую правку... тааааккк опять упало. Не понятно где.
Пойду ка я в деббагер. Дебаггер покликали, ага стало понятно, делаем правку
...иии... опять надо пойти пнуть API что бы проверить что правка валидная._

Как минимум тут уже несколько переключений контекста. Хорошо если нужно открывать postman, а если браузер.
Там же нотификации, и хоба почитать почту надо, а тут хоба колокольчик на ютубе.

А если нужна тяжелая подготовка данных, для которых например надо вызывать еще других API или по добавлять строк в базу данных.

Еще ситуация усугубляется, когда мы работаем с фронтендом в браузере.
Там ведь целый дивный мир, если мы не пишем стартовые страницы, то нужно пробираться сквозь дебри интерфейса,
как минимум проходить авторизацию, как максимум целые пользовательские сценарии из кучи шагов.

## Какая есть альтернатива

Как понятно из заголовка статьи - это тесты.
Имея хорошо настроенное окружение и процесс (об этом ниже), можно отлично войти в поток и просто фигачить качественный код до помутнения сознания.
Никаких переключений контекста, никаких нажатий мышкой.
Отвлекаемся на мессенджеры, почту, соцсети, и т.д. только как сами посчитаем нужным это сделать.

Основа этому - это *постоянная обратная связь от тестов*. Не нужно переключать контекст, что бы понять мой код работает или нет.

И вообще, прикиньте с тестами можно писать код не будучи подключенным к интернету (если не считать отсутствие stackoverflow за блокер).
Реально, я как то написал нужный кусок функционала для интеграции с командой заказчика, будучи в пути к заказчику без интернета.
Когда я добрался до рабочего места, я запустил и всё просто работало. До этого я 6 часов просто писал код.

Конечно не все тесты работают на продуктивность. Все мы знаем про пирамиду тестирования.
Так вот чем выше по пирамиде мы карабкаемся, тем меньше вклад тестов в продуктивность разработки и больше в другие характеристики.
То-есть да, **unit тесты**, которые многие критикуют, как раз **дают наибольший прирост к продуктивности.**

На самом деле прогресс шагнул и интеграционные тесты, в этом плане тоже не плохи, в текущее время.
Но есть конечно, но. Нужно помнить что на настройку интеграционных тестов нужно будет потратить немного больше времени.
Их нельзя просто сесть и писать. В большинстве своем надо стартануть какой-то процесс и может быть пару зависимостей в докере поднять.
Но в целом, когда этот этап пройден, написание интеграционных тестов тоже очень и очень помогает ускориться.

## Тесты как результат планирования

Не знаю как у кого, но у меня при написании кода часто было 2 проблемы:

1. Надобность закончить педалировать, если задача вылазит за пределы рабочего дня и вспомнить на следующий день где нужно продолжить.
2. Надобность отвлечься, на митинг, обед и т.д., а потом успешно вернуться и продолжить.

Как видите сводиться всё к одному и тому же, надо иметь возможность остановиться и продолжить с того места где остановился.

И тут тесты отлично помогают.


## Несколько простых правил для разработки и окружения, что бы скорость действительно была скоростью

### 1. Научитесь пользоваться IDE, и желательно без мыши

Я в основном использую IDE от JetBrains (Project Rider, IntelliJ IDEA, WebStorm).
Один из интересных приемов, которые я применяю в этих IDE - это генерация кода из тестов.
То есть, вместо того что бы накидывать какой-то дизайн в коде и потом писать на него тесты, я прямо начинаю писать тест.
Хороший старт, это тест _"Как я хочу использовать, то что мне нужно сделать"_.
Прямо в тесте начинаем использовать, то чего еще нет.
Далее идёт магия IDE, которую хорошо бы выучить и довезти до автоматизма.
IDE подсвечивает что, то что я использую в тесте, еще не существует. Так как использование мне уже нравиться, я просто жму ALT+ENTER
и вуа-ля мне предлагает создать разные примитивы в языке, класс, интерфейс, функцию, компонент и тд.

И я не отказываюсь от предложения IDE :)

С радостью соглашаемся на ее предложения. После этого *прямо в тестах* получаем что-то, что уже может вызываться.
Далее повторяем шаги с разными другими тестами. Когда результат уже выглядит как что-то большое,
например мы нагенерили несколько классов или что-то законченное,
например уже есть вполне себе функциональность,
можно перенести код в те места где он должен обитать. Нажимаем CTRL+SHIFT+O (команда перенести в файл, у вас могут быть другие комбинации), выбираем куда и всё, дальше IDE сама.

Это всё к тому что пользование IDE сильно упрощает и написание тестов и написание кода, а также влияет на скорость, как минимум не нужно будет брать в руки мышь и искать нужное место в интерфейсе что бы что-то нажать.

### 2. Настройте тесты так что бы их было легко запускать или перезапускать

Важно для всё того же фокуса и получение постоянной обратной связи.

Как немного в предыдущем разделе - современные IDE умеют это делать с достаточно большим успехом.
После изменения кода надо видеть упали или прошли тесты, какие тесты упали, как ситуация изменилась от предыдущего запуска.
И делать перезапуск надо часто, иначе можно пропустить важную обратную связь после очередного изменения, и придется тратить время на дебаг.
Без этого процесс будет не полноценным. Если понадобится отдельные усилия, что-бы запустить тесты, то увеличение оценок из-за тестирования плавно начнёт возвращаться.

Идеальный сценарий, это если тесты перезапускаются сами по изменению. Сделал изменения - ничего не нажал, а тесты тебе отрепортили всё хорошо или что-то нужно править.

### 3. Настройте тесты так что бы они **быстро** давали обратную связь

Еще не мало важный пункт, это сделать так что бы обратная связь была достаточно быстрой.
Как сказано в предыдущем разделе, обратная связь важна после каждого маленького изменения в коде.
Но что делать если тестов очень много или они очень медленно проходят и обратная связь растягивается на пол минуты, минуту или больше.

Первое - убедиться что железа на котором разрабатывается софт достаточно для быстрого запуска тестов.

Второе - убедиться что тесты распараллеливаются и утилизируют доступные ресурсы железа.

Третье - запускать частями. Реализовать это можно либо же структурно разделив проект и тесты составляющие и запускать тесты, которые относятся только к текущему модулю, пакету или что там поддерживается у языка.
Еще один способ - это запускать тесты исходя из покрытия. Есть достаточно много инструментов, которые считают покрытия тестами и исходя из покрытия строят карту зависимостей.
То есть какие куски кода затрагиваются во время запуска того или иного теста. Потом на основании этого запускаются только тесты, которые затрагивают место изменения.
Примеры таких инструментов:

- [JetBrains Project Rider](https://blog.jetbrains.com/dotnet/2018/07/20/unit-test-coverage-continuous-testing-now-rider/) умеет перезапускать тесты исходя из покрытия .NET кода.
- [NCrunch](https://www.ncrunch.net), нехило платная штука, но тоже позволяет себе устроить непрерывный оптимизированный цикл обратной связи от тестов.
- [WallabyJS](https://wallabyjs.com) - инструмент для JS который анализирует покрытие кода, и умело перезапускает тесты. Плюс имеет дополнительные возможности, такие как REPL из тестов.

Да эти примеры платные, но это инвестиция в собственную производительность. Покупая инструменты JetBrains последние 6 лет, я ни разу не пожалел денег потраченных на них.

### 4. Пишите тесты так что бы было легко понять где и почему падает

_Test_positive failed with reason expected true to be false._

Правда ничего не понятно?

Особенно если сравнить со следующей строкой:

_Plain_should_have_needed_attitude_right_after_start failed with reason expected plain.attitude to be 500m but got 120m_

Когда тест падает с результатом из первого примера, с большой долей вероятности придется запускать дебагер, во втором случае можно предположить причину падения и сразу же начать ее чинить получая дальше обратную связь от тестов.

### 5. Сделайте тесты не отъемной частью разработки

Худшее что можно сделать, это писать код и тесты отдельными этапами, например иметь отдельные задачи на написания кода и написание тестов.

Это крайне-крайне не производительный подход. Такой подход конечно оправдает и х3 увеличение оценки что-бы писать тесты.

Почему это плохо? Да потому что тесты отдельным этапом просто не несут ценности описанной выше, они не дают обратную связь после каждого изменения в коде.
А как мы уже выяснили обратная связь очень важна что-бы сохранять фокус и быть производительным.

Идеально конечно, практиковать TDD. Сам процесс настроен на обратную связь, маленькие итерации, и это некий формальный подход которому можно сесть и следовать.
Если же по какой-то причине, TDD кажется не подходящим, то хотя бы нужно стараться писать тесты вместе с кодом, так что бы тесты отвечали на вопрос, а делает ли код который я **только что написал**, то что задумано.

Я считаю что если тесты пишутся отдельным этапом, то лучше этого не делать, потому что это дикая потеря времени. Лучше всего его тратить на тесты которые выше по пирамиде, такие как например end-2-end.

## В заключение

Я постарался из своего опыта описать виденье того как перестать умножать свои оценки на некую константу, просто ради того что бы писать тесты.
Что это не нужно делать, не для того что бы скрыть цену тестов, а для того что бы показать что тесты на самом деле инструмент эффективности, при правильно поставленном процессе конечно.
Если процесс разработки настроен, то через короткий промежуток разработки оценки будут не увеличиваться, а уменьшатся просто из-за того что не нужно кликать бесконечные
флоу пользователя ради того что бы починить маленький баг, достаточно написать несколько тестов и раз убедиться что все работает, как и задумано.

Я умышленно не концентрировался на других характеристиках, которые улучшают или ухудшают тесты, это предмет других разговоров.

В этой же статье я попытался показать эффект от тестов на скорость разработки.
