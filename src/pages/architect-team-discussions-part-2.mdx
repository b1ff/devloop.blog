---
slug: "/blog/architect-team-discussions-part-2"
date: "2021-09-19"
author: "Евгений"
keywords: архитектура,команда архитекторов,solution architecture,software architect,командные процессы,конфликты,требования
---

# Подход к дискуссии в команде архитекторов. Часть 2

*Статья получилась длинная, поэтому я разбил ее на 2 части. В первой части фокус на важности
абстрагировании от конкретики в начале рассмотрения проблемы. Как свернуть дискуссию в конструктивное
русло и получить максимум для принятия решения. В этой части описано что делать, когда
требования согласовали внутри и дискуссия возвращается к решению, и что делать если есть несколько
равнозначных решений.*

## Переходим к решениям

<!-- cut -->
И так мы пришли к тому что в начале мы обсуждаем те требования которые надо учесть в решении,
до того как идти в какую то технологическую специфику.
Командой договорились о целях и о тех пунктах которых надо достичь. Теперь нам таки надой пойти в решение,
и обсудить ту или иную идею.

Предположим у нас есть несколько решений и все они уже попадают в требования. Те решения, которые не налазят на требования, мы не рассматриваем по умолчанию.
Точнее если представлять себе коллективную работу - то мы мягко напоминаем, что некоторое требование не учтено в решении и его надо или расширить,
или же не рассматривать.
<!-- cut -->

## Подробнее о ситуации

Для тех кто никогда не был в такой ситуации - представьте что у вас есть какое-то решение по требованиям. Но есть предлагаемые альтернативы.
Эти альтернативы могут выглядеть как и концептуально другое предложение, так и просто предложение подправить изначальное решение.
Например, у вас есть предложение сделать систему из 3‑х компонент, а кто-то предлагает один из компонентов разнести еще на 2 части, таким образом
задизайнив систему из 4-х компонент.
Грубо говоря спрашивают: "А почему не сделать Х?"
При том что предыдущая система удовлетворяла требования. Или нет...?

## Почему появляются альтернативы

Если подумать немного, то все мы люди :) Ваш кэп.

Всегда существует множество решений для одной и той же проблемы.

Что важно понять - это то что когда ты начинаешь практиковать не накатанный, не инерционный подход, всегда получается не на 100% идеально.
Я бы сказал что первые попытки хорошо если будут получаться на 50%.

Люди, которые предлагают альтернативы, думают что у них появился вариант как учесть больше.
То-есть у них **рождается новое требование, которое как кажется, должно улучшить дизайн и учесть больше возможных развитий событий.**
Или меньше, потому что кому-то может показаться, что текущее решение излишне сложно.
На каждом этапе предложения альтернативы главное это постоянно возращатся с уровня решения на уровень требований. Опять-таки, понимаем почему решение лучше через призму дополнительных аттрибутов качества которые они добавляют в систему.

## Как понять какое решение выбрать

Если они равнозначны, то можно конечно бросить монетку. Шутка.

Лучше подойти к этому процессу более осознанно и вынести выгоду из ситуации.
Если альтернативы вносят какие-то поправки в требования, то коллективно принимаем решение о том нужно ли это требование или нет.
Обычно это достаточно просто сделать, если в команде все адекватные люди.
Например, можно сделать простой pros and cons анализ.
На основе анализа можно понять дает ли требование выгоду с учётом всех компромиссов.

## Пример

Представим себе ситуацию, когда у нас есть задача сделать дизайн для коммуникации между несколькими сервисами.
Есть предложенный вариант использовать HTTPS и request-response который удовлетворяет всем изначальным требованиям.
Но при этом, кто-то из команды предлагает поставить очередь между сервисами.

Приводим разговор в плоскость требований. Что предлагающий хочет учесть посредством очереди?
Получаем следующий ответ:
- надежное приложение. Очередь может выступать буфером и в случае отказа одного из компонентов.
- коммуникация толерантная к всплескам нагрузки. Опять-таки, очередь выступает буфером и позволяет подождать пока всё сообщения будут обработаны, или уже устроить умное масштабирование по размеру очереди.

Хорошо, мы получили требования. Теперь обсуждаем нужны ли они нам? Являются ли они обязательными?

- Обсуждаем надежность - выглядит как что-то нужное. Но у надежности есть различные уровни такие как доступность, отказоустойчивость, возможность к восстановлению.
Договариваемся что достаточно будет 99.95% доступности, отказоустойчивость к выходу из строя нескольких запущенных копий приложения.
- Далее обсуждаем коммуникацию толерантную к всплескам нагрузки. Говорим о том что, иметь такую характеристику было бы хорошо, если есть условно дешевый способ, но это не принципиально для наших текущих требований. Намного важнее возможность к восстановлению после всплесков нагрузки.

Теперь у нас есть дополненные требования и 2 решения которые подходят под все требования. Делаем теперь на pros & cons анализ.

### Берём HTTPS request-response

| pros | cons |
|---|---|
| Коммуникация которая натурально поддерживается в браузерах | Нету встроенного механизма повтора |
| Понятная обработка ошибок | Обработка сообщения не гарантированна |
| Достаточно простой способ общения для разработчиков |  |
| Наличие готового инструментария для тестирования и отладки |  |

### Теперь очередь

| pros | cons |
|---|---|
| Гарантии обработки сообщения | Сложная обработка ошибок |
| Есть буфер для сообщений в случае нештатных ситуаций | Для браузера требует отдельного UX и технологий для доставки ответов |
|  | Требует дополнительных слоев логики связанных с транспортом, такие как идемпотентность обработчиков и роутинг |
|  | Требует дополнительных инструментов для тестирования и отладки |

Смотрим на pros & cons анализ и решаем что для нас скорость старта и простота для разработчиков важнее чем преимущества, которые дает очередь.
И останавливаемся на request-response.

Что важно, это то что в процессе pros & cons анализа, мы так же вывели еще одно - простота для разработки несет важную роль для текущих условий.

## Расширяем требования

После всех обсуждений хорошо бы задокументировать решения и требования которые мы вывели по итогу.

Всё это можно сразу вносить в документацию походу обсуждения.
Хорошо бы так же задокументировать что было отвергнуто и почему, т.к. это поможет ускорить дальнейшие разговоры. Чем больше требований будет описано или отвергнуто, тем проще будет строить решение, которое подходит под всё.

## Проверяем решение

Обычно реальная жизнь сложнее чем отдельно взятый пример для статьи. Разговоров и задокументированных требований может быть значительно больше.
Из практики иногда требовалось часа 4-6 обсуждать сложные решения.
После всех изменений хорошо бы перепроверить что, то решение которое получилось в конце всё еще удовлетворяет всем выведенным требованиям, ограничениям и тд.
Для этого можно взять формальные методы traceability требований, или хотя бы разок пройтись по требованиям глазами отвечая на вопрос "Как оно воплощенно в решении?".
Если ответ есть, то всё хорошо, если ответ затруднительный или его нет - то стоит подправить решение, до того момента пока все требования не окажутся покрытыми.

## Резюме

В двух частях рассмотрен процесс того как можно в команде, коллективно обсуждать, находить консенсус и приходить к более качественным и прагматичным решениям.
Надеюсь что это поможет кому-то избежать конфликтов, не продуманных решений и вообще построить более осознанный подход к архитектуре у себя.
Как минимум мне в свое время это помогло немного улучшить процессы. А этой статьей я постарался структурировать сделанное.
