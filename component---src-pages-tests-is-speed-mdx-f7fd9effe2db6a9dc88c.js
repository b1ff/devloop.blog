"use strict";(self.webpackChunklearning_architect_blog=self.webpackChunklearning_architect_blog||[]).push([[289],{8453:function(e,t,n){n.d(t,{RP:function(){return o}});var a=n(6540);const s=a.createContext({});function o(e){const t=a.useContext(s);return a.useMemo(()=>"function"==typeof e?e(t):{...t,...e},[t,e])}},8491:function(e,t,n){n.r(t);var a=n(8453),s=n(6540);function o(e){const t=Object.assign({h1:"h1",p:"p",h2:"h2",em:"em",strong:"strong",ol:"ol",li:"li",h3:"h3",ul:"ul",a:"a"},(0,a.RP)(),e.components);return s.createElement(s.Fragment,null,s.createElement(t.h1,null,"Tests are necessary for speed"),"\n","\n",s.createElement(t.p,null,"I constantly hear that in order to write tests, you need to increase the time estimate for the task by 1.2, 1.5, 2, 3 times.\nUsually, I don't argue with this, since the team knows best, but inside me there is often a simmering feeling, or at least a bubbling one.\nI would like to explain my view on automated tests and why I believe that such an increase is not entirely correct."),"\n","\n",s.createElement(t.h2,null,"How we usually develop"),"\n",s.createElement(t.p,null,"In this section, I mean scenarios where we care at least a little bit about the quality.\nSo, we have some project, let's say it's an API. Let's assume we need to extend that very API.\nIn any case, we need to check the result, that the API works as intended.\nTo do this, after each change, we start the process with the API. We go to some swagger or postman, make a request with the necessary data and check the result."),"\n",s.createElement(t.p,null,s.createElement(t.em,null,"So... something went wrong here... Okay, I see where it went wrong, fix it. It's working now. Make further changes... and again, it's failing. Not sure where.\nLet me go to the debugger. Call the debugger, okay, I see what's wrong now, fix it... and again, I need to go and check the API to see if the fix is valid.")),"\n",s.createElement(t.p,null,"At least a few context switches are involved here. It's good if we need to open postman, but if it's a browser.\nThere are notifications there, and suddenly we need to read our email or watch a video on YouTube."),"\n",s.createElement(t.p,null,"And if we need to prepare heavy data, for which, for example, we need to call other APIs or add rows to the database."),"\n",s.createElement(t.p,null,"The situation is exacerbated when we work with frontend in the browser.\nThere's a whole wonderful world there. If we're not writing starting pages, we need to navigate through the interface,\nat least go through the authorization, at most, complete entire user scenarios with multiple steps."),"\n",s.createElement(t.h2,null,"What is the alternative"),"\n",s.createElement(t.p,null,"As the title of the article suggests, the alternative is tests.\nWith a well-tuned environment and process (more on that below), you can easily get into the flow and just write quality code until your mind goes fuzzy.\nNo switching of contexts, no mouse clicks.\nGet distracted by messengers, email, social networks, and so on only when you feel it's necessary."),"\n",s.createElement(t.p,null,"The basis of this is ",s.createElement(t.em,null,"continuous feedback from tests"),". You don't need to switch contexts to understand whether my code works or not."),"\n",s.createElement(t.p,null,"And you know what? With tests, you can write code without being connected to the internet (if you don't count the absence of Stack Overflow as a blocker).\nI once wrote a necessary piece of functionality for integrating with a customer team while on the way to the customer, without internet access.\nWhen I got to my workplace, I ran the code and it just worked. Before that, I spent 6 hours just writing code."),"\n",s.createElement(t.p,null,"Of course, not all tests contribute equally to productivity. We all know about the testing pyramid.\nThe higher up the pyramid we climb, the less tests contribute to development productivity and the more they contribute to other characteristics.\nIn other words, ",s.createElement(t.strong,null,"unit tests"),", which many criticize, actually ",s.createElement(t.strong,null,"give the greatest productivity boost.")),"\n",s.createElement(t.p,null,"In reality, progress has been made, and integration tests are not bad in this regard at the moment.\nBut there is a catch. It's important to remember that setting up integration tests will take a little more time.\nYou can't just sit down and write them. In most cases, you need to start some process and maybe bring up a couple of dependencies in Docker.\nBut overall, when this stage is passed, writing integration tests also helps speed up the process."),"\n",s.createElement(t.h2,null,"Tests as a result of planning"),"\n",s.createElement(t.p,null,"I don't know about you, but when I write code, I often have two problems:"),"\n",s.createElement(t.ol,null,"\n",s.createElement(t.li,null,"The need to finish pedaling if the task goes beyond the working day and remember where to continue the next day."),"\n",s.createElement(t.li,null,"The need to get distracted by a meeting, lunch, etc., and then successfully return and continue."),"\n"),"\n",s.createElement(t.p,null,"As you can see, everything boils down to the same thing: you need to be able to stop and continue from where you left off."),"\n",s.createElement(t.p,null,"And this is where tests come in handy. If you write tests, you can stop at any time and continue the next day."),"\n",s.createElement(t.h2,null,"Some simple rules for development and environment setup to make speed really fast"),"\n",s.createElement(t.h3,null,"1. Learn to use the IDE, preferably without a mouse"),"\n",s.createElement(t.p,null,"I mostly use IDEs from JetBrains (Project Rider, IntelliJ IDEA, WebStorm).\nOne of the interesting techniques that I use in these IDEs is generating code from tests.\nThat is, instead of creating some design in code and then writing tests for it, I start writing tests directly.\nA good start is the test ",s.createElement(t.em,null,'"How I want to use what I need to do"'),".\nRight in the test, we start using something that doesn't exist yet.\nThen the magic of the IDE begins, which is good to learn and bring to automation.\nThe IDE highlights that what I'm using in the test doesn't exist yet. Since I already like using it, I just press ALT+ENTER\nand voila, it offers to create different language primitives, classes, interfaces, functions, components, etc."),"\n",s.createElement(t.p,null,"And I don't refuse the IDE's offer :)"),"\n",s.createElement(t.p,null,"We happily agree to its suggestions. After that, ",s.createElement(t.em,null,"right in the tests")," we get something that can already be called.\nThen we repeat the steps with different other tests. When the result looks like something big,\nfor example, we generated several classes or something finished,\nfor example, there is already quite functional code,\nwe can move the code to where it should reside. Press CTRL+SHIFT+O (move to file command, you may have other combinations), choose where and that's it, the IDE itself does the rest."),"\n",s.createElement(t.p,null,"All this is to say that using an IDE greatly simplifies writing tests and code, and also affects speed, at least you don't have to pick up the mouse and find the right place in the interface to click on something."),"\n",s.createElement(t.h3,null,"2. Set up tests to be easy to run or restart"),"\n",s.createElement(t.p,null,"Important for all the same focus and getting constant feedback."),"\n",s.createElement(t.p,null,"As a little in the previous section - modern IDEs can do this quite successfully.\nAfter making changes to the code, you need to see whether the tests passed or failed, which tests failed, and how the situation has changed since the last run.\nAnd you need to restart often, otherwise you can miss important feedback after the next change, and you will have to spend time debugging.\nWithout this, the process will not be complete. If it takes separate efforts to run the tests, the increase in ratings due to testing will gradually return."),"\n",s.createElement(t.p,null,"The ideal scenario is when the tests restart themselves on a change. Made a change - didn't press anything, and the tests reported to you that everything is good or something needs to be fixed."),"\n",s.createElement(t.h3,null,"3. Configure tests to provide ",s.createElement(t.strong,null,"quick")," feedback"),"\n",s.createElement(t.p,null,"Another important point is to make sure that the feedback is fast enough.\nAs mentioned in the previous section, feedback is important after every small change in the code.\nBut what if there are a lot of tests or they run very slowly, and the feedback takes half a minute, a minute, or more."),"\n",s.createElement(t.p,null,"First - make sure that the hardware on which the software is being developed is sufficient to quickly run tests."),"\n",s.createElement(t.p,null,"Second - make sure that the tests are parallelized and utilize the available hardware resources."),"\n",s.createElement(t.p,null,"Third - run tests in parts. This can be implemented by structurally dividing the project and the tests components and running only the tests that relate to the current module, package, or language-supported feature.\nAnother way is to run tests based on coverage. There are quite a few tools that calculate test coverage and build a dependency map based on it.\nThat is, which pieces of code are touched during the execution of a particular test. Then, based on this, only the tests that affect the modified area are run.\nExamples of such tools:"),"\n",s.createElement(t.ul,null,"\n",s.createElement(t.li,null,s.createElement(t.a,{href:"https://blog.jetbrains.com/dotnet/2018/07/20/unit-test-coverage-continuous-testing-now-rider/"},"JetBrains Project Rider")," can restart tests based on .NET code coverage."),"\n",s.createElement(t.li,null,s.createElement(t.a,{href:"https://www.ncrunch.net"},"NCrunch"),", a somewhat expensive tool, but it also allows you to set up a continuous optimized feedback loop from tests."),"\n",s.createElement(t.li,null,s.createElement(t.a,{href:"https://wallabyjs.com"},"WallabyJS")," - a tool for JS that analyzes code coverage and skillfully restarts tests. Plus, it has additional features such as REPL from tests."),"\n"),"\n",s.createElement(t.p,null,"Yes, these examples are paid, but it is an investment in your own productivity. Buying JetBrains tools for the last 6 years, I have never regretted the money spent on them."),"\n",s.createElement(t.h2,null,"4. Write tests so that it is easy to understand where and why they fail"),"\n",s.createElement(t.p,null,s.createElement(t.em,null,"Test_positive failed with reason expected true to be false.")),"\n",s.createElement(t.p,null,"Doesn't make sense, right?"),"\n",s.createElement(t.p,null,"Especially when compared to the following string:"),"\n",s.createElement(t.p,null,s.createElement(t.em,null,"Plain_should_have_needed_attitude_right_after_start failed with reason expected plain.attitude to be 500m but got 120m")),"\n",s.createElement(t.p,null,"When a test fails with the result from the first example, it will most likely require debugging. In the second case, you can assume the reason for the failure and immediately start fixing it, getting further feedback from the tests."),"\n",s.createElement(t.h2,null,"5. Make tests an integral part of development"),"\n",s.createElement(t.p,null,"The worst thing you can do is write code and tests as separate stages, for example, have separate tasks for writing code and writing tests."),"\n",s.createElement(t.p,null,"This is an extremely unproductive approach. Such an approach will certainly justify a x3 increase in estimates to write tests."),"\n",s.createElement(t.p,null,"Why is this bad? Because tests as a separate stage simply do not provide the value described above, they do not provide feedback after each change in the code.\nAnd as we have already established, feedback is crucial to stay focused and productive."),"\n",s.createElement(t.p,null,'Ideally, practice TDD. The process is designed for feedback, small iterations, and is a formal approach that can be learned and followed.\nIf, for some reason, TDD does not seem suitable, at least try to write tests along with the code so that the tests answer the question, "does the code I just wrote do what I intended it to do?"'),"\n",s.createElement(t.p,null,"I believe that if tests are written as a separate stage, it's better not to do it, because it's a waste of time. It's best to spend it on tests that are higher up the pyramid, such as end-to-end tests."),"\n",s.createElement(t.h2,null,"Conclusion"),"\n",s.createElement(t.p,null,"From my experience, I tried to describe a vision of how to stop multiplying estimates by some constant just for the sake of writing tests.\nThis is not something that should be done to hide the cost of tests, but to show that tests are actually a tool for efficiency, provided that the development process is set up correctly.\nIf the development process is set up properly, then over a short period of development, estimates will not increase, but decrease simply because there is no need to click endless user flows to fix a small bug - it is enough to write a few tests and verify that everything works as intended."),"\n",s.createElement(t.p,null,"I deliberately did not focus on other characteristics that improve or worsen tests, as this is the subject of other conversations."),"\n",s.createElement(t.p,null,"In this same article, I tried to show the effect of tests on development speed.\nI hope that this will help you to understand that tests are not a burden, but a tool that can help you to be more productive."))}t.default=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?s.createElement(t,e,s.createElement(o,e)):o(e)}}}]);
//# sourceMappingURL=component---src-pages-tests-is-speed-mdx-f7fd9effe2db6a9dc88c.js.map